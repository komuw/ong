package middleware

import (
	"context"
	"fmt"
	"net/http"
	"path"
	"strings"
	"time"

	"github.com/komuw/ong/cookie"
	"github.com/komuw/ong/internal/octx"
	"github.com/komuw/ong/log"
)

const logIDKey = string(octx.LogCtxKey)

// TODO:
//
// cleanUrl a new url path cleaned of any ./ or ../ elements.
// This func is fashioned after [url.URL.JoinPath]
func cleanUrl(url string) string {
	var p string

	if !strings.HasPrefix(url, "/") {
		// Return a relative path if u is relative,
		// but ensure that it contains no ../ elements.
		url = "/" + url
	}
	p = path.Clean(url)

	// path.Clean may remove any trailing slashes.
	// Preserve at least one.
	if strings.HasSuffix(url, "/") && !strings.HasSuffix(p, "/") {
		p += "/"
	}

	return p
}

// trace is a middleware that adds logID to request and response.
func trace(wrappedHandler http.Handler, domain string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		r.URL.Path = cleanUrl(r.URL.Path)

		fmt.Println("\t trace: r.URL.Path: ", r.Method, r.URL.Path)         // TODO:
		fmt.Println("\t trace: r.URL.String(): ", r.Method, r.URL.String()) // TODO:

		ctx := r.Context()

		// set cookie/headers/ctx for logID.
		logID := getLogId(r)
		ctx = context.WithValue(
			ctx,
			// using this custom key is important, instead of using `logIDKey`
			octx.LogCtxKey,
			logID,
		)
		r = r.WithContext(ctx)
		r.Header.Set(logIDKey, logID)
		w.Header().Set(logIDKey, logID)
		cookie.Set(
			w,
			logIDKey,
			logID,
			domain,
			// Hopefully 15mins is enough.
			// Google considers a session to be 30mins.
			// https://support.google.com/analytics/answer/2731565?hl=en#time-based-expiration
			15*time.Minute,
			false,
		)

		wrappedHandler.ServeHTTP(w, r)
	}
}

// getLogId returns a logID from the request or autogenerated if not available from the request.
func getLogId(req *http.Request) string {
	fromHeader := func(r *http.Request) string {
		if r != nil {
			if hdr := r.Header.Get(logIDKey); hdr != "" {
				return hdr
			}
		}
		return ""
	}

	fromCookie := func(r *http.Request) string {
		if r != nil {
			var cookies []*http.Cookie
			for _, v := range r.Cookies() {
				if v.Name == logIDKey && v.Value != "" {
					cookies = append(cookies, v)
				}
			}
			// there can be multiple cookies with the same name. get the latest
			if len(cookies) > 0 {
				return cookies[len(cookies)-1].Value
			}
		}
		return ""
	}

	fromCtx := func(ctx context.Context) string {
		return log.GetId(ctx) // we want a unique id, here.
	}

	// get logid in order of preference;
	// - http headers
	// - cookie
	// - context.Context

	if logID := fromHeader(req); logID != "" {
		return logID
	}

	if logID := fromCookie(req); logID != "" {
		return logID
	}

	return fromCtx(req.Context())
}
